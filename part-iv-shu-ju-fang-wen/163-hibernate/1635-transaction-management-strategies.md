### 16.3.5 Transaction management strategies

Both`TransactionTemplate`and`TransactionInterceptor`delegate the actual transaction handling to a`PlatformTransactionManager`instance, which can be a`HibernateTransactionManager`\(for a single Hibernate`SessionFactory`, using a`ThreadLocalSession`under the hood\) or a`JtaTransactionManager`\(delegating to the JTA subsystem of the container\) for Hibernate applications. You can even use a custom`PlatformTransactionManager`implementation. Switching from native Hibernate transaction management to JTA, such as when facing distributed transaction requirements for certain deployments of your application, is just a matter of configuration. Simply replace the Hibernate transaction manager with Spring’s JTA transaction implementation. Both transaction demarcation and data access code will work without changes, because they just use the generic transaction management APIs.

For distributed transactions across multiple Hibernate session factories, simply combine`JtaTransactionManager`as a transaction strategy with multiple`LocalSessionFactoryBean`definitions. Each DAO then gets one specific`SessionFactory`reference passed into its corresponding bean property. If all underlying JDBC data sources are transactional container ones, a business service can demarcate transactions across any number of DAOs and any number of session factories without special regard, as long as it is using`JtaTransactionManager`as the strategy.

Both`HibernateTransactionManager`and`JtaTransactionManager`allow for proper JVM-level cache handling with Hibernate, without container-specific transaction manager lookup or a JCA connector \(if you are not using EJB to initiate transactions\).

`HibernateTransactionManager`can export the Hibernate JDBC`Connection`to plain JDBC access code, for a specific`DataSource`. This capability allows for high-level transaction demarcation with mixed Hibernate and JDBC data access completely without JTA, if you are accessing only one database.`HibernateTransactionManager`automatically exposes the Hibernate transaction as a JDBC transaction if you have set up the passed-in`SessionFactory`with a`DataSource`through the`dataSource`property of the`LocalSessionFactoryBean`class. Alternatively, you can specify explicitly the`DataSource`for which the transactions are supposed to be exposed through the`dataSource`property of the`HibernateTransactionManager`class.

