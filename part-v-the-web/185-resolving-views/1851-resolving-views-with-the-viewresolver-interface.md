### 18.5.1Resolving views with the ViewResolver interface

As discussed in[Section18.3, “Implementing Controllers”](https://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-controller), all handler methods in the Spring Web MVC controllers must resolve to a logical view name, either explicitly \(e.g., by returning a`String`,`View`, or`ModelAndView`\) or implicitly \(i.e., based on conventions\). Views in Spring are addressed by a logical view name and are resolved by a view resolver. Spring comes with quite a few view resolvers. This table lists most of them; a couple of examples follow.

**Table18.3.View resolvers**

| ViewResolver | Description |
| :--- | :--- |
| `AbstractCachingViewResolver` | Abstract view resolver that caches views. Often views need preparation before they can be used; extending this view resolver provides caching. |
| `XmlViewResolver` | Implementation of`ViewResolver`that accepts a configuration file written in XML with the same DTD as Spring’s XML bean factories. The default configuration file is`/WEB-INF/views.xml`. |
| `ResourceBundleViewResolver` | Implementation of`ViewResolver`that uses bean definitions in a`ResourceBundle`, specified by the bundle base name. Typically you define the bundle in a properties file, located in the classpath. The default file name is`views.properties`. |
| `UrlBasedViewResolver` | Simple implementation of the`ViewResolver`interface that effects the direct resolution of logical view names to URLs, without an explicit mapping definition. This is appropriate if your logical names match the names of your view resources in a straightforward manner, without the need for arbitrary mappings. |
| `InternalResourceViewResolver` | Convenient subclass of`UrlBasedViewResolver`that supports`InternalResourceView`\(in effect, Servlets and JSPs\) and subclasses such as`JstlView`and`TilesView`. You can specify the view class for all views generated by this resolver by using`setViewClass(..)`. See the`UrlBasedViewResolver`javadocs for details. |
| `FreeMarkerViewResolver` | Convenient subclass of`UrlBasedViewResolver`that supports`FreeMarkerView`and custom subclasses of them. |
| `ContentNegotiatingViewResolver` | Implementation of the`ViewResolver`interface that resolves a view based on the request file name or`Accept`header. See[Section18.5.4, “ContentNegotiatingViewResolver”](https://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-multiple-representations). |

As an example, with JSP as a view technology, you can use the`UrlBasedViewResolver`. This view resolver translates a view name to a URL and hands the request over to the RequestDispatcher to render the view.

```java
<bean id="viewResolver"
		class="org.springframework.web.servlet.view.UrlBasedViewResolver">
	<property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/>
	<property name="prefix" value="/WEB-INF/jsp/"/>
	<property name="suffix" value=".jsp"/>
</bean>
```

When returning`test`as a logical view name, this view resolver forwards the request to the`RequestDispatcher`that will send the request to`/WEB-INF/jsp/test.jsp`.

When you combine different view technologies in a web application, you can use the`ResourceBundleViewResolver`:

```java
<bean id="viewResolver"
		class="org.springframework.web.servlet.view.ResourceBundleViewResolver">
	<property name="basename" value="views"/>
	<property name="defaultParentView" value="parentView"/>
</bean>
```

The`ResourceBundleViewResolver`inspects the`ResourceBundle`identified by the basename, and for each view it is supposed to resolve, it uses the value of the property`[viewname].(class)`as the view class and the value of the property`[viewname].url`as the view url. Examples can be found in the next chapter which covers view technologies. As you can see, you can identify a parent view, from which all views in the properties file "extend". This way you can specify a default view class, for example.

| ![](https://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/images/note.png) |
| :--- |
| Subclasses of`AbstractCachingViewResolver`cache view instances that they resolve. Caching improves performance of certain view technologies. It’s possible to turn off the cache by setting the`cache`property to`false`. Furthermore, if you must refresh a certain view at runtime \(for example when a FreeMarker template is modified\), you can use the`removeFromCache(String viewName, Locale loc)`method. |



